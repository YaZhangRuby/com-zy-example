### redis集群三种方式

redis包含三种集群策略：

**. 主从复制

. 哨兵

. 集群**

#### 1. 主从复制

在主从复制中，数据库分为两类：**主数据库(master)和从数据库(slave)**。

其中主从复制有如下特点：

**. 主数据库可以进行读写操作，当读写操作导致数据变化时，会自动将数据同步给从数据库；
. 从数据库一般都是只读的，并且接收主数据库同步过来的数据
. 一个master可以拥有多个slave，但是一个slave只能对应一个master**

**主从复制工作机制**

当slave启动后，主动向master发送SYNC命令。master接收到SYNC命令后在后台保存快照(RDB持久化)和缓存保存快照这段时间的命令，然后将保存的快照文件和缓存的命令发送给slave。slave接收到快照文件和命令后加载快照文件和缓存的执行命令。

复制初始化后，master每次接收到的写命令都会同步发送给slave，保证主从数据一致性。

**主从配置**

redis默认是主数据库，所以master无需配置，只需要修改slave的配置即可。


#### 2. 哨兵

**哨兵(一个进程)**的作用是**监控redis系统的运行状态**，它的功能如下：

**. 监控主从数据库是否正常运行
. master出现故障时，自动将slave转化为master
. 多哨兵配置的时候，哨兵之间也会自动监控
. 多个哨兵可以监控同一个redis**

**哨兵工作机制**

哨兵进程启动时会读取配置文件的内容，通过sentinel monitor master-name ip port quorum查找到master的ip端口。一个哨兵可以监控多个master数据库，只需要提供多个配置项即可。

同时配置文件还定义了与监控相关的参数，比如master多长时间无响应即可判定为下线。

哨兵启动后，会与要监控的master建立两条连接：

1. 一条连接用来订阅master的_sentinel_:hello频道与获取其他监控该master的哨兵节点信息
2. 另一条连接定期向master发送INFO等命令获取master本身的信息

与master建立连接后，哨兵会执行三个操作，这三个操作的发送频率可以在配置文件中配置：

1. 定期向master和slave发送INFO命令
2. 定期向master和slave的_sentinel_:hello频道发送自己的信息
3. 定期向master、slave和其他哨兵发送PING命令

发送INFO命令可以获取当前数据库的相关信息从而实现新节点的自动发现。所以哨兵只需要配置master数据库信息就可以自动发现其slave信息。获取到slave信息后，哨兵也会与slave建立两条连接执行监控。通过INFO命令，哨兵可以获取主从数据库的最新信息，并进行相应的操作，比如角色变更等。

接着哨兵向主从数据库的_sentinel_:hello频道发送信息，与同样监控这些数据库的哨兵共享自己的信息，发送内容为哨兵的ip端口、运行id、配置版本、master名字、master的ip端口，还有master的配置版本。这些信息有以下用处：

. 其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PIN命令
. 其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新

当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。发送频率可以配置，但是最长间隔时间为1s，可以通过sentinel down-after-milliseconds mymaster 600设置。

如果被ping的数据库或者节点超时未回复，哨兵认为其主观下线。如果下线的是master，哨兵会向其他哨兵点发送命令询问他们是否也认为该master主观下线，如果达到一定数目（即配置文件中的**quorum**）投票，哨兵会认为该master已经客观下线，并选举领头的哨兵节点对主从系统发起故障恢复。

如上文所说，哨兵认为master客观下线后，故障恢复的操作需要由选举的领头哨兵执行，选举采用Raft算法：

1. 发现master下线的哨兵节点（我们称它为A）向每个哨兵发送命令，要求对方选自己为领头哨兵
2. 如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵
3. 如果有超过一半的哨兵同意选举A为领头，则A当选
4. 如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出，此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票精选，直至选举出领头哨兵

选出领头哨兵后，领头者开始对进行故障恢复，从出现故障的master的从数据库中挑选一个来当选新的master，选择规则如下：

1. 所有在线的slave中选择优先级最高的，优先级可以通过slave-priority配置
2. 如果有多个最高优先级的slave，则选取复制偏移量最大（即复制越完整）的当选
3. 如果以上条件都一样，选取id最小的slave

挑选出需要继任的slaver后，领头哨兵向该数据库发送命令使其升格为master,然后再向其他slave发送命令接受新的master，最后更新数据。将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。

**哨兵配置**

哨兵配置的配置文件为sentinel.conf，设置主机名称、地址、端口，以及选举票数即恢复时最少需要几个哨兵节点同意。

```
sentinel monitor mymaster 192.168.0.107 6379 1
```

只要配置需要监控的master就可以了，哨兵会监控连接该master的slave。

启动哨兵节点：

```
redis-server sentinel.conf --sentinel &
```


#### 3. 集群

redis的哨兵模式基本已经可以实现高可用，读写分离，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现redis的分布式存储，也就是说每台redis节点上存储不同的内容。

   1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
   2、节点的fail是通过集群中超过半数的节点检测失效时才生效。
   3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
   4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node<->slot<->value。
   5、Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。
   
比如：现在存在3个主节点：A、B、C三个节点，它们可以是一个机器的三个端口，也可以是三台不同的服务器
