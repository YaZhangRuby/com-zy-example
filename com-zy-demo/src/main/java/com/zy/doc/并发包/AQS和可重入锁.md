### ReentrantLock和AQS的关系

    用java并发包下的ReentrantLock可以实现加锁和解锁，一般如下所示：

```
ReentrantLock lock = new ReentrantLock();
lock.lock();   //加锁

....   //处理业务逻辑

lock.unlock();    //解锁
```

   java并发包下很多api都是基于AQS实现加锁和解锁功能的，AQS是并发包的基础类。比如ReentrantLock和ReentrantReadWriteLock底层都是基于AQS来实现的。
   
   **AQS的全称是AbstractQueuedSynchronizer，抽象队列同步器。**
   
   ReentrantLock和AQS之间的关系如下图所示：说白了，ReentrantLock内部包含了一个AQS对象，也就是AbstractQueuedSynchronizer类型的对象。这个AQS对象对象就是ReentrantLock可以实现加锁和释放锁的关键性的核心组件。
   ![ReentrantLock和AQS的关系](./image/20190329-1.jpg) 
   
### ReentrantLock加锁和释放锁的底层原理

如果一个线程尝试用ReentrantLock的lock()方法进行加锁，会发生什么呢？
很简单，这个AQS对象内部有一个核心的变量叫做**state**，是int类型的，代表了**加锁的状态**。初始状态下，这个state的值是0。
另外，这个AQS内部还有一个**关键变量**，用来记录**当前加锁的是哪个线程**，初始化状态下，这个变量是null。
 ![AQS结构](./image/201903290002.jpg) 

接着线程1调用ReentrantLock的lock()方法尝试进行加锁，这个加锁的过程，直接就是用CAS操作将state值从0变为1。
如果之前没人加过锁，那么state的值肯定是0，此时线程1就可以加锁成功。
一旦线程1加锁成功了之后，就可以设置当前加锁线程是自己。所以大家看下面的图，就是线程1加锁的一个过程。
 ![ReentrantLock加锁过程](./image/201903290003.jpg) 
 
 说白了，就是并发包里一个核心组件，里面有state变量、加锁线程变量等核心的东西，维护了加锁状态。
 ReentrantLock这种东西只是一个外层的api，**内核中的锁机制实现都是依赖AQS组件的**。
 这个ReentrantLock之所以用Reentrant打头，意思就是它是一个可重入锁。
 
 可重入锁的意思是，**可以对一个ReentrantLock对象多次执行lock()加锁和unlock()释放锁，也就是可以对一个锁加多次，叫做可重入锁**。
 
 其实每次线程1可重入加锁一次，会判断一下当前加锁线程就是自己，那么它自己就可以**可重入多次加锁，每次加锁就是把state的值给累加1**。
 
 **接着，如果线程1加锁了之后，线程2再过来加锁会怎么样？**
 
 可以看看锁互斥是怎么实现的？线程2过来一看，state的值不是0，所以CAS操作将state从0变为1的过程会失败，因为state的值当前为1，说明已经锁已经被其他线程获取了。
 接着线程2会看一下，是不是自己之前加的锁？发现不是，"**加锁线程**"这个变量明确记录了是线程1占有了这个锁，所以线程2此时就是加锁失败。
  ![ReentrantLock互斥锁实现](./image/201903290004.jpg) 
  
  接着线程2会将自己放入AQS中的一个等待队列，因为自己尝试加锁失败了，此时就要将自己放入队列中来等待，等待线程1释放锁之后，自己就可以重新尝试加锁了。
  所以，可以看到，AQS内部还有一个等待队列，专门放那些加锁失败的线程！
  
  如下图所示：
  ![ReentrantLock等待队列](./image/201903290005.jpg) 
  
  接着，线程1在执行完自己的业务逻辑代码之后，就会释放锁！它**释放锁**的过程非常简单，**就是将AQS内的state变量的值递减1，如果state值为0，则彻底释放锁，会将"加锁线程"变量也设置为null!**
  
  整个过程如下图所示：
    ![ReentrantLock加锁整个过程](./image/201903290006.jpg) 
    
  接下来，会**从等待队列的对头唤醒线程2重新尝试加锁**。
  线程2重新尝试加锁，这是还是用CAS操作将state从0变为1，此时就会成功，成功之后代表加锁成功，就会将state设置为1。
  
  此外，还要把"加锁线程"设置为线程2，同时线程2就从等待队列中出队了。
  
  最后再看一张完整的过程：
      ![ReentrantLock加锁整个过程](./image/201903290007.jpg) 
      
      
### 总结

   **AQS就是一个并发包的基础组件，用来实现各种锁，各种同步组件的。它包含了state变量、加锁线程、等待队列等并发中的核心组件。**






