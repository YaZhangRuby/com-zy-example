### Mysql的四种事务隔离级别

**事务名称**|**A事务**|**B事务**
:---:|:---:|:---:
读未提交|修改未提交|已生效
读已提交|修改已提交|已生效
可重复读|修改已提交|未生效
串行化|B有查询则A不能修改|---

1. 事务的基本要素(ACID):

   . A(Atomicity):**原子性**
   
   . C(Consistency):**一致性**
   
   . I(Isolation)：**隔离性**
   
   . D(Durability):**持久性**

2. 事务引发的并发问题： **脏读、不可重复度、幻读**

3. 事务隔离级别：**读未提交(read-uncommitted)、读已提交(read-uncommitted)、可重复读(repeatable-read)、串行化(serializable)**


```
select @@tx_isolation   //查看当前回话事务级别

set session transaction isolation level serializable   //设置当前回话事务级别

start transaction //开始事务

commit   //提交事务

rollback  //回滚事务
```

#### 注意：

1. Mysql**默认**的隔离级别是**可重复读**，但一般数据库都设置为**读已提交**

2. 读未提交 -- 产生**脏读**，即A事务修改未提交，B事务也能读到；

3. 读已提交 -- 解决脏读，会产生**不可重复读**。即A事务修改已提交，就会被B事务读到；如果事务A回滚，B事务两次读到的结果是不一致的(针对update操作)；

4. 可重复读 -- 解决了不可重复读，但会出现**幻读**。即在一个事务中，两次查询的结果不一致。(针对insert和delete操作)

5. 不可重复读和幻读很容易混淆，不可重复读侧重于update,幻读侧重于insert和delete。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

6. 可重复读隔离级别下使用了MVCC机制，select操作不会更新版本号，是快照读(历史版本)；insert、update和delete会更新版本号，是当前读(当前版本)。

7. 不同事务对表和行的影响：

   . 事务隔离级别为**读提交**时，**写数据**只会锁住相应的**行**；
   
   . 事务隔离级别为**可重复读**时，如果检索条件**有索引**（包括主键索引）的时候，默认加锁方式是next-key锁，会**锁行**；如果检索条件**没有索引**，更新数据时会**锁住整张表**。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。
   
   . 事务隔离级别为**串行化**时，读写数据都会**锁住整张表**
   
8. 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大












